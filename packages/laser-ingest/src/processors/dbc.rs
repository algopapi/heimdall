use super::{FilterContribution, Processor};
use crate::{
    processors::events::{
        DbcBalanceUpdatePayload, DbcSwapPayload, PoolEvent, StreamedEvent,
    },
    types::PoolMeta,
};
use async_trait::async_trait;
use borsh::BorshDeserialize;
use helius_laserstream::grpc::{
    subscribe_update::UpdateOneof, SubscribeUpdate, Transaction, TransactionStatusMeta,
    SubscribeRequestFilterAccounts, SubscribeRequestFilterTransactions,
};
use redis::aio::MultiplexedConnection as RedisConn;
use std::collections::HashMap;

// TODO: fetch from config
const DBC_PROGRAM_ID: &str = "dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN";
const ANCHOR_CPI_LOG_DISCRIMINATOR: [u8; 8] = [228, 69, 165, 46, 81, 203, 154, 29];

// generated by IDL build step of DBC program (copied from examples)
mod idl {
    use super::*;
    include!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../laser-ingest/examples/idl.rs"
    ));
}
use idl::{EvtSwap, SWAP_EVENT_DISCRIMINATOR};

pub struct DbcProcessor;

impl DbcProcessor {
    fn find_swap_event(
        tx: &Transaction,
        meta: &TransactionStatusMeta,
    ) -> Option<EvtSwap> {
        let account_keys = tx.message.as_ref()?.account_keys.as_slice();
        let inner_instructions = meta.inner_instructions.as_slice();
        let dbc_program_bytes = bs58::decode(DBC_PROGRAM_ID).into_vec().ok()?;

        for inner_ix_list in inner_instructions {
            for ix in &inner_ix_list.instructions {
                let program_id_index = ix.program_id_index as usize;
                if let Some(program_id_bytes) = account_keys.get(program_id_index) {
                    if *program_id_bytes == dbc_program_bytes {
                        if ix.data.starts_with(&ANCHOR_CPI_LOG_DISCRIMINATOR) {
                            let event_with_disc = &ix.data[8..];
                            if event_with_disc.starts_with(&SWAP_EVENT_DISCRIMINATOR) {
                                let event_data = &event_with_disc[8..];
                                if let Ok(evt) = EvtSwap::try_from_slice(event_data) {
                                    return Some(evt);
                                }
                            }
                        }
                    }
                }
            }
        }
        None
    }
}

async fn publish_event(
    event: StreamedEvent<'_>,
    conn: &mut RedisConn,
) -> redis::RedisResult<()> {
    let json = serde_json::to_string(&event).unwrap();
    tracing::info!(event = ?event, "Publishing pool event to Redis");
    redis::cmd("XADD")
        .arg("heimdall:pool_events")
        .arg("*")
        .arg("data")
        .arg(json)
        .query_async(conn)
        .await
}

#[async_trait]
impl Processor for DbcProcessor {
    fn build_filters(&self, pool: &PoolMeta) -> FilterContribution {
        let mut accounts = HashMap::new();
        if let Some(vault) = &pool.quote_vault {
            accounts.insert(
                format!("{}_quote_vault", pool.pool_id),
                SubscribeRequestFilterAccounts {
                    account: vec![vault.clone()],
                    ..Default::default()
                },
            );
        }

        let mut txs = HashMap::new();
        txs.insert(
            format!("{}_dbc_swaps", pool.pool_id),
            SubscribeRequestFilterTransactions {
                account_include: vec![
                    DBC_PROGRAM_ID.to_owned(),
                    pool.pool_id.clone(), // ensure pool-specific txs come through
                ],
                ..Default::default()
            },
        );
        FilterContribution {
            accounts,
            transactions: txs,
        }
    }

    async fn handle_update(
        &self,
        pool: &PoolMeta,
        update: &SubscribeUpdate,
        conn: &mut RedisConn,
    ) {
        if let Some(oneof) = &update.update_oneof {
            match oneof {
                UpdateOneof::Transaction(tx_update) => {
                    if let Some(tx_info) = &tx_update.transaction {
                        if let (Some(tx), Some(meta)) = (&tx_info.transaction, &tx_info.meta) {
                            if let Some(evt) = Self::find_swap_event(tx, meta) {
                                // ensure pool matches
                                let evt_pool = bs58::encode(evt.pool).into_string();
                                if evt_pool != pool.pool_id {
                                    return; // not our pool
                                }

                                let payload = DbcSwapPayload {
                                    signature: bs58::encode(&tx_info.signature).into_string(),
                                    input_amount: evt.swap_result.actual_input_amount,
                                    output_amount: evt.swap_result.output_amount as u64,
                                    next_sqrt_price: evt.swap_result.next_sqrt_price,
                                };
                                let _ = publish_event(
                                    StreamedEvent {
                                        pool_id: &pool.pool_id,
                                        variant: "dbc",
                                        event: PoolEvent::DbcSwap(payload),
                                    },
                                    conn,
                                )
                                .await;
                            }
                        }
                    }
                }
                UpdateOneof::Account(acc_update) => {
                    if let Some(acc) = &acc_update.account {
                        // quote vault balance update
                        if let Some(vault) = &pool.quote_vault {
                            let pubkey_str = bs58::encode(&acc.pubkey).into_string();
                            if &pubkey_str == vault {
                                if acc.data.len() >= 72 {
                                    let bal_raw =
                                        u64::from_le_bytes(acc.data[64..72].try_into().unwrap());
                                    let bal_dec = bal_raw as f64 / 10u64.pow(9) as f64; // WSOL 9 decimals

                                    let payload = DbcBalanceUpdatePayload {
                                        quote_vault_address: vault.clone(),
                                        new_balance: bal_dec,
                                    };
                                    let _ = publish_event(
                                        StreamedEvent {
                                            pool_id: &pool.pool_id,
                                            variant: "dbc",
                                            event: PoolEvent::DbcBalanceUpdate(payload),
                                        },
                                        conn,
                                    )
                                    .await;
                                }
                            }
                        }
                    }
                }
                _ => {}
            }
        }
    }
} 