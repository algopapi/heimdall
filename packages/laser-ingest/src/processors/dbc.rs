use super::{FilterContribution, Processor};
use async_trait::async_trait;
use borsh::BorshDeserialize;
use helius_laserstream::grpc::{
    subscribe_update::UpdateOneof, SubscribeUpdate, Transaction,
    TransactionStatusMeta, SubscribeRequestFilterAccounts, SubscribeRequestFilterTransactions,
};
use redis::aio::MultiplexedConnection as RedisConn;
use serde::Serialize;
use std::collections::HashMap;

use crate::types::{PoolMeta};

// TODO: fetch from config
const DBC_PROGRAM_ID: &str = "dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN";
const ANCHOR_CPI_LOG_DISCRIMINATOR: [u8; 8] = [228, 69, 165, 46, 81, 203, 154, 29];

// generated by IDL build step of DBC program (copied from examples)
mod idl {
    use super::*;
    use serde::Serialize;
    include!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/../laser-ingest/examples/idl.rs"
    ));
}
use idl::{EvtSwap, SWAP_EVENT_DISCRIMINATOR};

#[derive(Serialize, Debug)]
struct PoolSwapPayload {
    pool_id: String,
    variant: &'static str, // "dbc"
    signature: String,
    input_amount: u64,
    output_amount: u64,
    next_sqrt_price: u128,
}

pub struct DbcProcessor;

impl DbcProcessor {
    fn find_swap_event(tx: &Transaction, meta: &TransactionStatusMeta) -> Option<EvtSwap> {
        let account_keys = tx.message.as_ref()?.account_keys.as_slice();
        let inner_instructions = meta.inner_instructions.as_slice();
        let dbc_program_bytes = bs58::decode(DBC_PROGRAM_ID).into_vec().ok()?;

        for inner_ix_list in inner_instructions {
            for ix in &inner_ix_list.instructions {
                let program_id_index = ix.program_id_index as usize;
                if let Some(program_id_bytes) = account_keys.get(program_id_index) {
                    if *program_id_bytes == dbc_program_bytes {
                        if ix.data.starts_with(&ANCHOR_CPI_LOG_DISCRIMINATOR) {
                            let event_with_disc = &ix.data[8..];
                            if event_with_disc.starts_with(&SWAP_EVENT_DISCRIMINATOR) {
                                let event_data = &event_with_disc[8..];
                                if let Ok(evt) = EvtSwap::try_from_slice(event_data) {
                                    return Some(evt);
                                }
                            }
                        }
                    }
                }
            }
        }
        None
    }
}

#[async_trait]
impl Processor for DbcProcessor {
    fn build_filters(&self, pool: &PoolMeta) -> FilterContribution {
        let mut accounts = HashMap::new();
        if let Some(vault) = &pool.quote_vault {
            accounts.insert(
                format!("{}_quote_vault", pool.pool_id),
                SubscribeRequestFilterAccounts {
                    account: vec![vault.clone()],
                    ..Default::default()
                },
            );
        }

        let mut txs = HashMap::new();
        txs.insert(
            format!("{}_dbc_swaps", pool.pool_id),
            SubscribeRequestFilterTransactions {
                account_include: vec![
                    DBC_PROGRAM_ID.to_owned(),
                    pool.pool_id.clone(), // ensure pool-specific txs come through
                ],
                ..Default::default()
            },
        );
        FilterContribution { accounts, transactions: txs }
    }

    async fn handle_update(&self, pool: &PoolMeta, update: &SubscribeUpdate, conn: &mut RedisConn) {
        if let Some(oneof) = &update.update_oneof {
            match oneof {
                UpdateOneof::Transaction(tx_update) => {
                    if let Some(tx_info) = &tx_update.transaction {
                        if let (Some(tx), Some(meta)) = (&tx_info.transaction, &tx_info.meta) {
                            if let Some(evt) = Self::find_swap_event(tx, meta) {
                                // ensure pool matches
                                let evt_pool = bs58::encode(evt.pool).into_string();
                                if evt_pool != pool.pool_id {
                                    return; // not our pool
                                }
                                let payload = PoolSwapPayload {
                                    pool_id: pool.pool_id.clone(),
                                    variant: "dbc",
                                    signature: bs58::encode(&tx_info.signature).into_string(),
                                    input_amount: evt.swap_result.actual_input_amount,
                                    output_amount: evt.swap_result.output_amount as u64,
                                    next_sqrt_price: evt.swap_result.next_sqrt_price,
                                };
                                let json = serde_json::to_string(&payload).unwrap();
                                let _ : redis::RedisResult<()> = redis::cmd("XADD")
                                    .arg("heimdall:pools:swaps")
                                    .arg("*")
                                    .arg("data")
                                    .arg(json)
                                    .query_async::<_, ()>(conn)
                                    .await;
                                tracing::info!(?payload, "DBC swap event published");
                            }
                        }
                    }
                }
                UpdateOneof::Account(acc_update) => {
                    if let Some(acc) = &acc_update.account {
                        // quote vault balance update
                        if let Some(vault) = &pool.quote_vault {
                            let pubkey_str = bs58::encode(&acc.pubkey).into_string();
                            if &pubkey_str == vault {
                                if acc.data.len() >= 72 {
                                    let bal_raw = u64::from_le_bytes(acc.data[64..72].try_into().unwrap());
                                    let bal_dec = bal_raw as f64 / 10u64.pow(9) as f64; // WSOL 9 decimals
                                    tracing::info!(pool_id = %pool.pool_id, balance = bal_dec, "Quote vault balance update");
                                }
                            }
                        }
                    }
                }
                _ => {}
            }
        }
    }
} 